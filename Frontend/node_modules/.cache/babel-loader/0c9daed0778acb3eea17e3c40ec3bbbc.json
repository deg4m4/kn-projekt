{"ast":null,"code":"import { Factory } from '../Factory.js';\nimport { Line } from './Line.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nimport { Path } from './Path.js';\nexport class Arrow extends Line {\n  _sceneFunc(ctx) {\n    super._sceneFunc(ctx);\n    var PI2 = Math.PI * 2;\n    var points = this.points();\n    var tp = points;\n    var fromTension = this.tension() !== 0 && points.length > 4;\n    if (fromTension) {\n      tp = this.getTensionPoints();\n    }\n    var length = this.pointerLength();\n    var n = points.length;\n    var dx, dy;\n    if (fromTension) {\n      const lp = [tp[tp.length - 4], tp[tp.length - 3], tp[tp.length - 2], tp[tp.length - 1], points[n - 2], points[n - 1]];\n      const lastLength = Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], 'C', lp);\n      const previous = Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);\n      dx = points[n - 2] - previous.x;\n      dy = points[n - 1] - previous.y;\n    } else {\n      dx = points[n - 2] - points[n - 4];\n      dy = points[n - 1] - points[n - 3];\n    }\n    var radians = (Math.atan2(dy, dx) + PI2) % PI2;\n    var width = this.pointerWidth();\n    if (this.pointerAtEnding()) {\n      ctx.save();\n      ctx.beginPath();\n      ctx.translate(points[n - 2], points[n - 1]);\n      ctx.rotate(radians);\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-length, width / 2);\n      ctx.lineTo(-length, -width / 2);\n      ctx.closePath();\n      ctx.restore();\n      this.__fillStroke(ctx);\n    }\n    if (this.pointerAtBeginning()) {\n      ctx.save();\n      ctx.beginPath();\n      ctx.translate(points[0], points[1]);\n      if (fromTension) {\n        dx = (tp[0] + tp[2]) / 2 - points[0];\n        dy = (tp[1] + tp[3]) / 2 - points[1];\n      } else {\n        dx = points[2] - points[0];\n        dy = points[3] - points[1];\n      }\n      ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-length, width / 2);\n      ctx.lineTo(-length, -width / 2);\n      ctx.closePath();\n      ctx.restore();\n      this.__fillStroke(ctx);\n    }\n  }\n  __fillStroke(ctx) {\n    var isDashEnabled = this.dashEnabled();\n    if (isDashEnabled) {\n      this.attrs.dashEnabled = false;\n      ctx.setLineDash([]);\n    }\n    ctx.fillStrokeShape(this);\n    if (isDashEnabled) {\n      this.attrs.dashEnabled = true;\n    }\n  }\n  getSelfRect() {\n    const lineRect = super.getSelfRect();\n    const offset = this.pointerWidth() / 2;\n    return {\n      x: lineRect.x - offset,\n      y: lineRect.y - offset,\n      width: lineRect.width + offset * 2,\n      height: lineRect.height + offset * 2\n    };\n  }\n}\nArrow.prototype.className = 'Arrow';\n_registerNode(Arrow);\nFactory.addGetterSetter(Arrow, 'pointerLength', 10, getNumberValidator());\nFactory.addGetterSetter(Arrow, 'pointerWidth', 10, getNumberValidator());\nFactory.addGetterSetter(Arrow, 'pointerAtBeginning', false);\nFactory.addGetterSetter(Arrow, 'pointerAtEnding', true);","map":null,"metadata":{},"sourceType":"module"}