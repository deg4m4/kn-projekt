{"ast":null,"code":"import { Util, Transform } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { Konva } from './Global.js';\nimport { DD } from './DragAndDrop.js';\nimport { getNumberValidator, getStringValidator, getBooleanValidator } from './Validators.js';\nvar ABSOLUTE_OPACITY = 'absoluteOpacity',\n  ALL_LISTENERS = 'allEventListeners',\n  ABSOLUTE_TRANSFORM = 'absoluteTransform',\n  ABSOLUTE_SCALE = 'absoluteScale',\n  CANVAS = 'canvas',\n  CHANGE = 'Change',\n  CHILDREN = 'children',\n  KONVA = 'konva',\n  LISTENING = 'listening',\n  MOUSEENTER = 'mouseenter',\n  MOUSELEAVE = 'mouseleave',\n  NAME = 'name',\n  SET = 'set',\n  SHAPE = 'Shape',\n  SPACE = ' ',\n  STAGE = 'stage',\n  TRANSFORM = 'transform',\n  UPPER_STAGE = 'Stage',\n  VISIBLE = 'visible',\n  TRANSFORM_CHANGE_STR = ['xChange.konva', 'yChange.konva', 'scaleXChange.konva', 'scaleYChange.konva', 'skewXChange.konva', 'skewYChange.konva', 'rotationChange.konva', 'offsetXChange.konva', 'offsetYChange.konva', 'transformsEnabledChange.konva'].join(SPACE);\nlet idCounter = 1;\nexport class Node {\n  constructor(config) {\n    this._id = idCounter++;\n    this.eventListeners = {};\n    this.attrs = {};\n    this.index = 0;\n    this._allEventListeners = null;\n    this.parent = null;\n    this._cache = new Map();\n    this._attachedDepsListeners = new Map();\n    this._lastPos = null;\n    this._batchingTransformChange = false;\n    this._needClearTransformCache = false;\n    this._filterUpToDate = false;\n    this._isUnderCache = false;\n    this._dragEventId = null;\n    this._shouldFireChangeEvents = false;\n    this.setAttrs(config);\n    this._shouldFireChangeEvents = true;\n  }\n  hasChildren() {\n    return false;\n  }\n  _clearCache(attr) {\n    if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) && this._cache.get(attr)) {\n      this._cache.get(attr).dirty = true;\n    } else if (attr) {\n      this._cache.delete(attr);\n    } else {\n      this._cache.clear();\n    }\n  }\n  _getCache(attr, privateGetter) {\n    var cache = this._cache.get(attr);\n    var isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;\n    var invalid = cache === undefined || isTransform && cache.dirty === true;\n    if (invalid) {\n      cache = privateGetter.call(this);\n      this._cache.set(attr, cache);\n    }\n    return cache;\n  }\n  _calculate(name, deps, getter) {\n    if (!this._attachedDepsListeners.get(name)) {\n      const depsString = deps.map(dep => dep + 'Change.konva').join(SPACE);\n      this.on(depsString, () => {\n        this._clearCache(name);\n      });\n      this._attachedDepsListeners.set(name, true);\n    }\n    return this._getCache(name, getter);\n  }\n  _getCanvasCache() {\n    return this._cache.get(CANVAS);\n  }\n  _clearSelfAndDescendantCache(attr) {\n    this._clearCache(attr);\n    if (attr === ABSOLUTE_TRANSFORM) {\n      this.fire('absoluteTransformChange');\n    }\n  }\n  clearCache() {\n    if (this._cache.has(CANVAS)) {\n      const {\n        scene,\n        filter,\n        hit\n      } = this._cache.get(CANVAS);\n      Util.releaseCanvas(scene, filter, hit);\n      this._cache.delete(CANVAS);\n    }\n    this._clearSelfAndDescendantCache();\n    this._requestDraw();\n    return this;\n  }\n  cache(config) {\n    var conf = config || {};\n    var rect = {};\n    if (conf.x === undefined || conf.y === undefined || conf.width === undefined || conf.height === undefined) {\n      rect = this.getClientRect({\n        skipTransform: true,\n        relativeTo: this.getParent()\n      });\n    }\n    var width = Math.ceil(conf.width || rect.width),\n      height = Math.ceil(conf.height || rect.height),\n      pixelRatio = conf.pixelRatio,\n      x = conf.x === undefined ? Math.floor(rect.x) : conf.x,\n      y = conf.y === undefined ? Math.floor(rect.y) : conf.y,\n      offset = conf.offset || 0,\n      drawBorder = conf.drawBorder || false,\n      hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;\n    if (!width || !height) {\n      Util.error('Can not cache the node. Width or height of the node equals 0. Caching is skipped.');\n      return;\n    }\n    width += offset * 2 + 1;\n    height += offset * 2 + 1;\n    x -= offset;\n    y -= offset;\n    var cachedSceneCanvas = new SceneCanvas({\n        pixelRatio: pixelRatio,\n        width: width,\n        height: height\n      }),\n      cachedFilterCanvas = new SceneCanvas({\n        pixelRatio: pixelRatio,\n        width: 0,\n        height: 0\n      }),\n      cachedHitCanvas = new HitCanvas({\n        pixelRatio: hitCanvasPixelRatio,\n        width: width,\n        height: height\n      }),\n      sceneContext = cachedSceneCanvas.getContext(),\n      hitContext = cachedHitCanvas.getContext();\n    cachedHitCanvas.isCache = true;\n    cachedSceneCanvas.isCache = true;\n    this._cache.delete(CANVAS);\n    this._filterUpToDate = false;\n    if (conf.imageSmoothingEnabled === false) {\n      cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;\n      cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;\n    }\n    sceneContext.save();\n    hitContext.save();\n    sceneContext.translate(-x, -y);\n    hitContext.translate(-x, -y);\n    this._isUnderCache = true;\n    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\n    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);\n    this.drawScene(cachedSceneCanvas, this);\n    this.drawHit(cachedHitCanvas, this);\n    this._isUnderCache = false;\n    sceneContext.restore();\n    hitContext.restore();\n    if (drawBorder) {\n      sceneContext.save();\n      sceneContext.beginPath();\n      sceneContext.rect(0, 0, width, height);\n      sceneContext.closePath();\n      sceneContext.setAttr('strokeStyle', 'red');\n      sceneContext.setAttr('lineWidth', 5);\n      sceneContext.stroke();\n      sceneContext.restore();\n    }\n    this._cache.set(CANVAS, {\n      scene: cachedSceneCanvas,\n      filter: cachedFilterCanvas,\n      hit: cachedHitCanvas,\n      x: x,\n      y: y\n    });\n    this._requestDraw();\n    return this;\n  }\n  isCached() {\n    return this._cache.has(CANVAS);\n  }\n  getClientRect(config) {\n    throw new Error('abstract \"getClientRect\" method call');\n  }\n  _transformedRect(rect, top) {\n    var points = [{\n      x: rect.x,\n      y: rect.y\n    }, {\n      x: rect.x + rect.width,\n      y: rect.y\n    }, {\n      x: rect.x + rect.width,\n      y: rect.y + rect.height\n    }, {\n      x: rect.x,\n      y: rect.y + rect.height\n    }];\n    var minX, minY, maxX, maxY;\n    var trans = this.getAbsoluteTransform(top);\n    points.forEach(function (point) {\n      var transformed = trans.point(point);\n      if (minX === undefined) {\n        minX = maxX = transformed.x;\n        minY = maxY = transformed.y;\n      }\n      minX = Math.min(minX, transformed.x);\n      minY = Math.min(minY, transformed.y);\n      maxX = Math.max(maxX, transformed.x);\n      maxY = Math.max(maxY, transformed.y);\n    });\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n  _drawCachedSceneCanvas(context) {\n    context.save();\n    context._applyOpacity(this);\n    context._applyGlobalCompositeOperation(this);\n    const canvasCache = this._getCanvasCache();\n    context.translate(canvasCache.x, canvasCache.y);\n    var cacheCanvas = this._getCachedSceneCanvas();\n    var ratio = cacheCanvas.pixelRatio;\n    context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);\n    context.restore();\n  }\n  _drawCachedHitCanvas(context) {\n    var canvasCache = this._getCanvasCache(),\n      hitCanvas = canvasCache.hit;\n    context.save();\n    context.translate(canvasCache.x, canvasCache.y);\n    context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);\n    context.restore();\n  }\n  _getCachedSceneCanvas() {\n    var filters = this.filters(),\n      cachedCanvas = this._getCanvasCache(),\n      sceneCanvas = cachedCanvas.scene,\n      filterCanvas = cachedCanvas.filter,\n      filterContext = filterCanvas.getContext(),\n      len,\n      imageData,\n      n,\n      filter;\n    if (filters) {\n      if (!this._filterUpToDate) {\n        var ratio = sceneCanvas.pixelRatio;\n        filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);\n        try {\n          len = filters.length;\n          filterContext.clear();\n          filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);\n          imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());\n          for (n = 0; n < len; n++) {\n            filter = filters[n];\n            if (typeof filter !== 'function') {\n              Util.error('Filter should be type of function, but got ' + typeof filter + ' instead. Please check correct filters');\n              continue;\n            }\n            filter.call(this, imageData);\n            filterContext.putImageData(imageData, 0, 0);\n          }\n        } catch (e) {\n          Util.error('Unable to apply filter. ' + e.message + ' This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.');\n        }\n        this._filterUpToDate = true;\n      }\n      return filterCanvas;\n    }\n    return sceneCanvas;\n  }\n  on(evtStr, handler) {\n    this._cache && this._cache.delete(ALL_LISTENERS);\n    if (arguments.length === 3) {\n      return this._delegate.apply(this, arguments);\n    }\n    var events = evtStr.split(SPACE),\n      len = events.length,\n      n,\n      event,\n      parts,\n      baseEvent,\n      name;\n    for (n = 0; n < len; n++) {\n      event = events[n];\n      parts = event.split('.');\n      baseEvent = parts[0];\n      name = parts[1] || '';\n      if (!this.eventListeners[baseEvent]) {\n        this.eventListeners[baseEvent] = [];\n      }\n      this.eventListeners[baseEvent].push({\n        name: name,\n        handler: handler\n      });\n    }\n    return this;\n  }\n  off(evtStr, callback) {\n    var events = (evtStr || '').split(SPACE),\n      len = events.length,\n      n,\n      t,\n      event,\n      parts,\n      baseEvent,\n      name;\n    this._cache && this._cache.delete(ALL_LISTENERS);\n    if (!evtStr) {\n      for (t in this.eventListeners) {\n        this._off(t);\n      }\n    }\n    for (n = 0; n < len; n++) {\n      event = events[n];\n      parts = event.split('.');\n      baseEvent = parts[0];\n      name = parts[1];\n      if (baseEvent) {\n        if (this.eventListeners[baseEvent]) {\n          this._off(baseEvent, name, callback);\n        }\n      } else {\n        for (t in this.eventListeners) {\n          this._off(t, name, callback);\n        }\n      }\n    }\n    return this;\n  }\n  dispatchEvent(evt) {\n    var e = {\n      target: this,\n      type: evt.type,\n      evt: evt\n    };\n    this.fire(evt.type, e);\n    return this;\n  }\n  addEventListener(type, handler) {\n    this.on(type, function (evt) {\n      handler.call(this, evt.evt);\n    });\n    return this;\n  }\n  removeEventListener(type) {\n    this.off(type);\n    return this;\n  }\n  _delegate(event, selector, handler) {\n    var stopNode = this;\n    this.on(event, function (evt) {\n      var targets = evt.target.findAncestors(selector, true, stopNode);\n      for (var i = 0; i < targets.length; i++) {\n        evt = Util.cloneObject(evt);\n        evt.currentTarget = targets[i];\n        handler.call(targets[i], evt);\n      }\n    });\n  }\n  remove() {\n    if (this.isDragging()) {\n      this.stopDrag();\n    }\n    DD._dragElements.delete(this._id);\n    this._remove();\n    return this;\n  }\n  _clearCaches() {\n    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\n    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);\n    this._clearSelfAndDescendantCache(STAGE);\n    this._clearSelfAndDescendantCache(VISIBLE);\n    this._clearSelfAndDescendantCache(LISTENING);\n  }\n  _remove() {\n    this._clearCaches();\n    var parent = this.getParent();\n    if (parent && parent.children) {\n      parent.children.splice(this.index, 1);\n      parent._setChildrenIndices();\n      this.parent = null;\n    }\n  }\n  destroy() {\n    this.remove();\n    this.clearCache();\n    return this;\n  }\n  getAttr(attr) {\n    var method = 'get' + Util._capitalize(attr);\n    if (Util._isFunction(this[method])) {\n      return this[method]();\n    }\n    return this.attrs[attr];\n  }\n  getAncestors() {\n    var parent = this.getParent(),\n      ancestors = [];\n    while (parent) {\n      ancestors.push(parent);\n      parent = parent.getParent();\n    }\n    return ancestors;\n  }\n  getAttrs() {\n    return this.attrs || {};\n  }\n  setAttrs(config) {\n    this._batchTransformChanges(() => {\n      var key, method;\n      if (!config) {\n        return this;\n      }\n      for (key in config) {\n        if (key === CHILDREN) {\n          continue;\n        }\n        method = SET + Util._capitalize(key);\n        if (Util._isFunction(this[method])) {\n          this[method](config[key]);\n        } else {\n          this._setAttr(key, config[key]);\n        }\n      }\n    });\n    return this;\n  }\n  isListening() {\n    return this._getCache(LISTENING, this._isListening);\n  }\n  _isListening(relativeTo) {\n    const listening = this.listening();\n    if (!listening) {\n      return false;\n    }\n    const parent = this.getParent();\n    if (parent && parent !== relativeTo && this !== relativeTo) {\n      return parent._isListening(relativeTo);\n    } else {\n      return true;\n    }\n  }\n  isVisible() {\n    return this._getCache(VISIBLE, this._isVisible);\n  }\n  _isVisible(relativeTo) {\n    const visible = this.visible();\n    if (!visible) {\n      return false;\n    }\n    const parent = this.getParent();\n    if (parent && parent !== relativeTo && this !== relativeTo) {\n      return parent._isVisible(relativeTo);\n    } else {\n      return true;\n    }\n  }\n  shouldDrawHit(top) {\n    let skipDragCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (top) {\n      return this._isVisible(top) && this._isListening(top);\n    }\n    var layer = this.getLayer();\n    var layerUnderDrag = false;\n    DD._dragElements.forEach(elem => {\n      if (elem.dragStatus !== 'dragging') {\n        return;\n      } else if (elem.node.nodeType === 'Stage') {\n        layerUnderDrag = true;\n      } else if (elem.node.getLayer() === layer) {\n        layerUnderDrag = true;\n      }\n    });\n    var dragSkip = !skipDragCheck && !Konva.hitOnDragEnabled && layerUnderDrag;\n    return this.isListening() && this.isVisible() && !dragSkip;\n  }\n  show() {\n    this.visible(true);\n    return this;\n  }\n  hide() {\n    this.visible(false);\n    return this;\n  }\n  getZIndex() {\n    return this.index || 0;\n  }\n  getAbsoluteZIndex() {\n    var depth = this.getDepth(),\n      that = this,\n      index = 0,\n      nodes,\n      len,\n      n,\n      child;\n    function addChildren(children) {\n      nodes = [];\n      len = children.length;\n      for (n = 0; n < len; n++) {\n        child = children[n];\n        index++;\n        if (child.nodeType !== SHAPE) {\n          nodes = nodes.concat(child.getChildren().slice());\n        }\n        if (child._id === that._id) {\n          n = len;\n        }\n      }\n      if (nodes.length > 0 && nodes[0].getDepth() <= depth) {\n        addChildren(nodes);\n      }\n    }\n    if (that.nodeType !== UPPER_STAGE) {\n      addChildren(that.getStage().getChildren());\n    }\n    return index;\n  }\n  getDepth() {\n    var depth = 0,\n      parent = this.parent;\n    while (parent) {\n      depth++;\n      parent = parent.parent;\n    }\n    return depth;\n  }\n  _batchTransformChanges(func) {\n    this._batchingTransformChange = true;\n    func();\n    this._batchingTransformChange = false;\n    if (this._needClearTransformCache) {\n      this._clearCache(TRANSFORM);\n      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n    }\n    this._needClearTransformCache = false;\n  }\n  setPosition(pos) {\n    this._batchTransformChanges(() => {\n      this.x(pos.x);\n      this.y(pos.y);\n    });\n    return this;\n  }\n  getPosition() {\n    return {\n      x: this.x(),\n      y: this.y()\n    };\n  }\n  getRelativePointerPosition() {\n    if (!this.getStage()) {\n      return null;\n    }\n    var pos = this.getStage().getPointerPosition();\n    if (!pos) {\n      return null;\n    }\n    var transform = this.getAbsoluteTransform().copy();\n    transform.invert();\n    return transform.point(pos);\n  }\n  getAbsolutePosition(top) {\n    let haveCachedParent = false;\n    let parent = this.parent;\n    while (parent) {\n      if (parent.isCached()) {\n        haveCachedParent = true;\n        break;\n      }\n      parent = parent.parent;\n    }\n    if (haveCachedParent && !top) {\n      top = true;\n    }\n    var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(),\n      absoluteTransform = new Transform(),\n      offset = this.offset();\n    absoluteTransform.m = absoluteMatrix.slice();\n    absoluteTransform.translate(offset.x, offset.y);\n    return absoluteTransform.getTranslation();\n  }\n  setAbsolutePosition(pos) {\n    var origTrans = this._clearTransform();\n    this.attrs.x = origTrans.x;\n    this.attrs.y = origTrans.y;\n    delete origTrans.x;\n    delete origTrans.y;\n    this._clearCache(TRANSFORM);\n    var it = this._getAbsoluteTransform().copy();\n    it.invert();\n    it.translate(pos.x, pos.y);\n    pos = {\n      x: this.attrs.x + it.getTranslation().x,\n      y: this.attrs.y + it.getTranslation().y\n    };\n    this._setTransform(origTrans);\n    this.setPosition({\n      x: pos.x,\n      y: pos.y\n    });\n    this._clearCache(TRANSFORM);\n    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n    return this;\n  }\n  _setTransform(trans) {\n    var key;\n    for (key in trans) {\n      this.attrs[key] = trans[key];\n    }\n  }\n  _clearTransform() {\n    var trans = {\n      x: this.x(),\n      y: this.y(),\n      rotation: this.rotation(),\n      scaleX: this.scaleX(),\n      scaleY: this.scaleY(),\n      offsetX: this.offsetX(),\n      offsetY: this.offsetY(),\n      skewX: this.skewX(),\n      skewY: this.skewY()\n    };\n    this.attrs.x = 0;\n    this.attrs.y = 0;\n    this.attrs.rotation = 0;\n    this.attrs.scaleX = 1;\n    this.attrs.scaleY = 1;\n    this.attrs.offsetX = 0;\n    this.attrs.offsetY = 0;\n    this.attrs.skewX = 0;\n    this.attrs.skewY = 0;\n    return trans;\n  }\n  move(change) {\n    var changeX = change.x,\n      changeY = change.y,\n      x = this.x(),\n      y = this.y();\n    if (changeX !== undefined) {\n      x += changeX;\n    }\n    if (changeY !== undefined) {\n      y += changeY;\n    }\n    this.setPosition({\n      x: x,\n      y: y\n    });\n    return this;\n  }\n  _eachAncestorReverse(func, top) {\n    var family = [],\n      parent = this.getParent(),\n      len,\n      n;\n    if (top && top._id === this._id) {\n      return;\n    }\n    family.unshift(this);\n    while (parent && (!top || parent._id !== top._id)) {\n      family.unshift(parent);\n      parent = parent.parent;\n    }\n    len = family.length;\n    for (n = 0; n < len; n++) {\n      func(family[n]);\n    }\n  }\n  rotate(theta) {\n    this.rotation(this.rotation() + theta);\n    return this;\n  }\n  moveToTop() {\n    if (!this.parent) {\n      Util.warn('Node has no parent. moveToTop function is ignored.');\n      return false;\n    }\n    var index = this.index,\n      len = this.parent.getChildren().length;\n    if (index < len - 1) {\n      this.parent.children.splice(index, 1);\n      this.parent.children.push(this);\n      this.parent._setChildrenIndices();\n      return true;\n    }\n    return false;\n  }\n  moveUp() {\n    if (!this.parent) {\n      Util.warn('Node has no parent. moveUp function is ignored.');\n      return false;\n    }\n    var index = this.index,\n      len = this.parent.getChildren().length;\n    if (index < len - 1) {\n      this.parent.children.splice(index, 1);\n      this.parent.children.splice(index + 1, 0, this);\n      this.parent._setChildrenIndices();\n      return true;\n    }\n    return false;\n  }\n  moveDown() {\n    if (!this.parent) {\n      Util.warn('Node has no parent. moveDown function is ignored.');\n      return false;\n    }\n    var index = this.index;\n    if (index > 0) {\n      this.parent.children.splice(index, 1);\n      this.parent.children.splice(index - 1, 0, this);\n      this.parent._setChildrenIndices();\n      return true;\n    }\n    return false;\n  }\n  moveToBottom() {\n    if (!this.parent) {\n      Util.warn('Node has no parent. moveToBottom function is ignored.');\n      return false;\n    }\n    var index = this.index;\n    if (index > 0) {\n      this.parent.children.splice(index, 1);\n      this.parent.children.unshift(this);\n      this.parent._setChildrenIndices();\n      return true;\n    }\n    return false;\n  }\n  setZIndex(zIndex) {\n    if (!this.parent) {\n      Util.warn('Node has no parent. zIndex parameter is ignored.');\n      return this;\n    }\n    if (zIndex < 0 || zIndex >= this.parent.children.length) {\n      Util.warn('Unexpected value ' + zIndex + ' for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to ' + (this.parent.children.length - 1) + '.');\n    }\n    var index = this.index;\n    this.parent.children.splice(index, 1);\n    this.parent.children.splice(zIndex, 0, this);\n    this.parent._setChildrenIndices();\n    return this;\n  }\n  getAbsoluteOpacity() {\n    return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);\n  }\n  _getAbsoluteOpacity() {\n    var absOpacity = this.opacity();\n    var parent = this.getParent();\n    if (parent && !parent._isUnderCache) {\n      absOpacity *= parent.getAbsoluteOpacity();\n    }\n    return absOpacity;\n  }\n  moveTo(newContainer) {\n    if (this.getParent() !== newContainer) {\n      this._remove();\n      newContainer.add(this);\n    }\n    return this;\n  }\n  toObject() {\n    var obj = {},\n      attrs = this.getAttrs(),\n      key,\n      val,\n      getter,\n      defaultValue,\n      nonPlainObject;\n    obj.attrs = {};\n    for (key in attrs) {\n      val = attrs[key];\n      nonPlainObject = Util.isObject(val) && !Util._isPlainObject(val) && !Util._isArray(val);\n      if (nonPlainObject) {\n        continue;\n      }\n      getter = typeof this[key] === 'function' && this[key];\n      delete attrs[key];\n      defaultValue = getter ? getter.call(this) : null;\n      attrs[key] = val;\n      if (defaultValue !== val) {\n        obj.attrs[key] = val;\n      }\n    }\n    obj.className = this.getClassName();\n    return Util._prepareToStringify(obj);\n  }\n  toJSON() {\n    return JSON.stringify(this.toObject());\n  }\n  getParent() {\n    return this.parent;\n  }\n  findAncestors(selector, includeSelf, stopNode) {\n    var res = [];\n    if (includeSelf && this._isMatch(selector)) {\n      res.push(this);\n    }\n    var ancestor = this.parent;\n    while (ancestor) {\n      if (ancestor === stopNode) {\n        return res;\n      }\n      if (ancestor._isMatch(selector)) {\n        res.push(ancestor);\n      }\n      ancestor = ancestor.parent;\n    }\n    return res;\n  }\n  isAncestorOf(node) {\n    return false;\n  }\n  findAncestor(selector, includeSelf, stopNode) {\n    return this.findAncestors(selector, includeSelf, stopNode)[0];\n  }\n  _isMatch(selector) {\n    if (!selector) {\n      return false;\n    }\n    if (typeof selector === 'function') {\n      return selector(this);\n    }\n    var selectorArr = selector.replace(/ /g, '').split(','),\n      len = selectorArr.length,\n      n,\n      sel;\n    for (n = 0; n < len; n++) {\n      sel = selectorArr[n];\n      if (!Util.isValidSelector(sel)) {\n        Util.warn('Selector \"' + sel + '\" is invalid. Allowed selectors examples are \"#foo\", \".bar\" or \"Group\".');\n        Util.warn('If you have a custom shape with such className, please change it to start with upper letter like \"Triangle\".');\n        Util.warn('Konva is awesome, right?');\n      }\n      if (sel.charAt(0) === '#') {\n        if (this.id() === sel.slice(1)) {\n          return true;\n        }\n      } else if (sel.charAt(0) === '.') {\n        if (this.hasName(sel.slice(1))) {\n          return true;\n        }\n      } else if (this.className === sel || this.nodeType === sel) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getLayer() {\n    var parent = this.getParent();\n    return parent ? parent.getLayer() : null;\n  }\n  getStage() {\n    return this._getCache(STAGE, this._getStage);\n  }\n  _getStage() {\n    var parent = this.getParent();\n    if (parent) {\n      return parent.getStage();\n    } else {\n      return undefined;\n    }\n  }\n  fire(eventType) {\n    let evt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let bubble = arguments.length > 2 ? arguments[2] : undefined;\n    evt.target = evt.target || this;\n    if (bubble) {\n      this._fireAndBubble(eventType, evt);\n    } else {\n      this._fire(eventType, evt);\n    }\n    return this;\n  }\n  getAbsoluteTransform(top) {\n    if (top) {\n      return this._getAbsoluteTransform(top);\n    } else {\n      return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);\n    }\n  }\n  _getAbsoluteTransform(top) {\n    var at;\n    if (top) {\n      at = new Transform();\n      this._eachAncestorReverse(function (node) {\n        var transformsEnabled = node.transformsEnabled();\n        if (transformsEnabled === 'all') {\n          at.multiply(node.getTransform());\n        } else if (transformsEnabled === 'position') {\n          at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());\n        }\n      }, top);\n      return at;\n    } else {\n      at = this._cache.get(ABSOLUTE_TRANSFORM) || new Transform();\n      if (this.parent) {\n        this.parent.getAbsoluteTransform().copyInto(at);\n      } else {\n        at.reset();\n      }\n      var transformsEnabled = this.transformsEnabled();\n      if (transformsEnabled === 'all') {\n        at.multiply(this.getTransform());\n      } else if (transformsEnabled === 'position') {\n        const x = this.attrs.x || 0;\n        const y = this.attrs.y || 0;\n        const offsetX = this.attrs.offsetX || 0;\n        const offsetY = this.attrs.offsetY || 0;\n        at.translate(x - offsetX, y - offsetY);\n      }\n      at.dirty = false;\n      return at;\n    }\n  }\n  getAbsoluteScale(top) {\n    var parent = this;\n    while (parent) {\n      if (parent._isUnderCache) {\n        top = parent;\n      }\n      parent = parent.getParent();\n    }\n    const transform = this.getAbsoluteTransform(top);\n    const attrs = transform.decompose();\n    return {\n      x: attrs.scaleX,\n      y: attrs.scaleY\n    };\n  }\n  getAbsoluteRotation() {\n    return this.getAbsoluteTransform().decompose().rotation;\n  }\n  getTransform() {\n    return this._getCache(TRANSFORM, this._getTransform);\n  }\n  _getTransform() {\n    var _a, _b;\n    var m = this._cache.get(TRANSFORM) || new Transform();\n    m.reset();\n    var x = this.x(),\n      y = this.y(),\n      rotation = Konva.getAngle(this.rotation()),\n      scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1,\n      scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1,\n      skewX = this.attrs.skewX || 0,\n      skewY = this.attrs.skewY || 0,\n      offsetX = this.attrs.offsetX || 0,\n      offsetY = this.attrs.offsetY || 0;\n    if (x !== 0 || y !== 0) {\n      m.translate(x, y);\n    }\n    if (rotation !== 0) {\n      m.rotate(rotation);\n    }\n    if (skewX !== 0 || skewY !== 0) {\n      m.skew(skewX, skewY);\n    }\n    if (scaleX !== 1 || scaleY !== 1) {\n      m.scale(scaleX, scaleY);\n    }\n    if (offsetX !== 0 || offsetY !== 0) {\n      m.translate(-1 * offsetX, -1 * offsetY);\n    }\n    m.dirty = false;\n    return m;\n  }\n  clone(obj) {\n    var attrs = Util.cloneObject(this.attrs),\n      key,\n      allListeners,\n      len,\n      n,\n      listener;\n    for (key in obj) {\n      attrs[key] = obj[key];\n    }\n    var node = new this.constructor(attrs);\n    for (key in this.eventListeners) {\n      allListeners = this.eventListeners[key];\n      len = allListeners.length;\n      for (n = 0; n < len; n++) {\n        listener = allListeners[n];\n        if (listener.name.indexOf(KONVA) < 0) {\n          if (!node.eventListeners[key]) {\n            node.eventListeners[key] = [];\n          }\n          node.eventListeners[key].push(listener);\n        }\n      }\n    }\n    return node;\n  }\n  _toKonvaCanvas(config) {\n    config = config || {};\n    var box = this.getClientRect();\n    var stage = this.getStage(),\n      x = config.x !== undefined ? config.x : Math.floor(box.x),\n      y = config.y !== undefined ? config.y : Math.floor(box.y),\n      pixelRatio = config.pixelRatio || 1,\n      canvas = new SceneCanvas({\n        width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),\n        height: config.height || Math.ceil(box.height) || (stage ? stage.height() : 0),\n        pixelRatio: pixelRatio\n      }),\n      context = canvas.getContext();\n    if (config.imageSmoothingEnabled === false) {\n      context._context.imageSmoothingEnabled = false;\n    }\n    context.save();\n    if (x || y) {\n      context.translate(-1 * x, -1 * y);\n    }\n    this.drawScene(canvas);\n    context.restore();\n    return canvas;\n  }\n  toCanvas(config) {\n    return this._toKonvaCanvas(config)._canvas;\n  }\n  toDataURL(config) {\n    config = config || {};\n    var mimeType = config.mimeType || null,\n      quality = config.quality || null;\n    var url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);\n    if (config.callback) {\n      config.callback(url);\n    }\n    return url;\n  }\n  toImage(config) {\n    return new Promise((resolve, reject) => {\n      try {\n        const callback = config === null || config === void 0 ? void 0 : config.callback;\n        if (callback) delete config.callback;\n        Util._urlToImage(this.toDataURL(config), function (img) {\n          resolve(img);\n          callback === null || callback === void 0 ? void 0 : callback(img);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n  toBlob(config) {\n    return new Promise((resolve, reject) => {\n      try {\n        const callback = config === null || config === void 0 ? void 0 : config.callback;\n        if (callback) delete config.callback;\n        this.toCanvas(config).toBlob(blob => {\n          resolve(blob);\n          callback === null || callback === void 0 ? void 0 : callback(blob);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n  setSize(size) {\n    this.width(size.width);\n    this.height(size.height);\n    return this;\n  }\n  getSize() {\n    return {\n      width: this.width(),\n      height: this.height()\n    };\n  }\n  getClassName() {\n    return this.className || this.nodeType;\n  }\n  getType() {\n    return this.nodeType;\n  }\n  getDragDistance() {\n    if (this.attrs.dragDistance !== undefined) {\n      return this.attrs.dragDistance;\n    } else if (this.parent) {\n      return this.parent.getDragDistance();\n    } else {\n      return Konva.dragDistance;\n    }\n  }\n  _off(type, name, callback) {\n    var evtListeners = this.eventListeners[type],\n      i,\n      evtName,\n      handler;\n    for (i = 0; i < evtListeners.length; i++) {\n      evtName = evtListeners[i].name;\n      handler = evtListeners[i].handler;\n      if ((evtName !== 'konva' || name === 'konva') && (!name || evtName === name) && (!callback || callback === handler)) {\n        evtListeners.splice(i, 1);\n        if (evtListeners.length === 0) {\n          delete this.eventListeners[type];\n          break;\n        }\n        i--;\n      }\n    }\n  }\n  _fireChangeEvent(attr, oldVal, newVal) {\n    this._fire(attr + CHANGE, {\n      oldVal: oldVal,\n      newVal: newVal\n    });\n  }\n  addName(name) {\n    if (!this.hasName(name)) {\n      var oldName = this.name();\n      var newName = oldName ? oldName + ' ' + name : name;\n      this.name(newName);\n    }\n    return this;\n  }\n  hasName(name) {\n    if (!name) {\n      return false;\n    }\n    const fullName = this.name();\n    if (!fullName) {\n      return false;\n    }\n    var names = (fullName || '').split(/\\s/g);\n    return names.indexOf(name) !== -1;\n  }\n  removeName(name) {\n    var names = (this.name() || '').split(/\\s/g);\n    var index = names.indexOf(name);\n    if (index !== -1) {\n      names.splice(index, 1);\n      this.name(names.join(' '));\n    }\n    return this;\n  }\n  setAttr(attr, val) {\n    var func = this[SET + Util._capitalize(attr)];\n    if (Util._isFunction(func)) {\n      func.call(this, val);\n    } else {\n      this._setAttr(attr, val);\n    }\n    return this;\n  }\n  _requestDraw() {\n    if (Konva.autoDrawEnabled) {\n      const drawNode = this.getLayer() || this.getStage();\n      drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();\n    }\n  }\n  _setAttr(key, val) {\n    var oldVal = this.attrs[key];\n    if (oldVal === val && !Util.isObject(val)) {\n      return;\n    }\n    if (val === undefined || val === null) {\n      delete this.attrs[key];\n    } else {\n      this.attrs[key] = val;\n    }\n    if (this._shouldFireChangeEvents) {\n      this._fireChangeEvent(key, oldVal, val);\n    }\n    this._requestDraw();\n  }\n  _setComponentAttr(key, component, val) {\n    var oldVal;\n    if (val !== undefined) {\n      oldVal = this.attrs[key];\n      if (!oldVal) {\n        this.attrs[key] = this.getAttr(key);\n      }\n      this.attrs[key][component] = val;\n      this._fireChangeEvent(key, oldVal, val);\n    }\n  }\n  _fireAndBubble(eventType, evt, compareShape) {\n    if (evt && this.nodeType === SHAPE) {\n      evt.target = this;\n    }\n    var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === 'Stage' && !compareShape);\n    if (!shouldStop) {\n      this._fire(eventType, evt);\n      var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);\n      if ((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble) {\n        if (compareShape && compareShape.parent) {\n          this._fireAndBubble.call(this.parent, eventType, evt, compareShape);\n        } else {\n          this._fireAndBubble.call(this.parent, eventType, evt);\n        }\n      }\n    }\n  }\n  _getProtoListeners(eventType) {\n    let listeners = this._cache.get(ALL_LISTENERS);\n    if (!listeners) {\n      listeners = {};\n      let obj = Object.getPrototypeOf(this);\n      while (obj) {\n        if (!obj.eventListeners) {\n          obj = Object.getPrototypeOf(obj);\n          continue;\n        }\n        for (var event in obj.eventListeners) {\n          const newEvents = obj.eventListeners[event];\n          const oldEvents = listeners[event] || [];\n          listeners[event] = newEvents.concat(oldEvents);\n        }\n        obj = Object.getPrototypeOf(obj);\n      }\n      this._cache.set(ALL_LISTENERS, listeners);\n    }\n    return listeners[eventType];\n  }\n  _fire(eventType, evt) {\n    evt = evt || {};\n    evt.currentTarget = this;\n    evt.type = eventType;\n    const topListeners = this._getProtoListeners(eventType);\n    if (topListeners) {\n      for (var i = 0; i < topListeners.length; i++) {\n        topListeners[i].handler.call(this, evt);\n      }\n    }\n    const selfListeners = this.eventListeners[eventType];\n    if (selfListeners) {\n      for (var i = 0; i < selfListeners.length; i++) {\n        selfListeners[i].handler.call(this, evt);\n      }\n    }\n  }\n  draw() {\n    this.drawScene();\n    this.drawHit();\n    return this;\n  }\n  _createDragElement(evt) {\n    var pointerId = evt ? evt.pointerId : undefined;\n    var stage = this.getStage();\n    var ap = this.getAbsolutePosition();\n    var pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap;\n    DD._dragElements.set(this._id, {\n      node: this,\n      startPointerPos: pos,\n      offset: {\n        x: pos.x - ap.x,\n        y: pos.y - ap.y\n      },\n      dragStatus: 'ready',\n      pointerId\n    });\n  }\n  startDrag(evt) {\n    let bubbleEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!DD._dragElements.has(this._id)) {\n      this._createDragElement(evt);\n    }\n    const elem = DD._dragElements.get(this._id);\n    elem.dragStatus = 'dragging';\n    this.fire('dragstart', {\n      type: 'dragstart',\n      target: this,\n      evt: evt && evt.evt\n    }, bubbleEvent);\n  }\n  _setDragPosition(evt, elem) {\n    const pos = this.getStage()._getPointerById(elem.pointerId);\n    if (!pos) {\n      return;\n    }\n    var newNodePos = {\n      x: pos.x - elem.offset.x,\n      y: pos.y - elem.offset.y\n    };\n    var dbf = this.dragBoundFunc();\n    if (dbf !== undefined) {\n      const bounded = dbf.call(this, newNodePos, evt);\n      if (!bounded) {\n        Util.warn('dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.');\n      } else {\n        newNodePos = bounded;\n      }\n    }\n    if (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) {\n      this.setAbsolutePosition(newNodePos);\n      this._requestDraw();\n    }\n    this._lastPos = newNodePos;\n  }\n  stopDrag(evt) {\n    const elem = DD._dragElements.get(this._id);\n    if (elem) {\n      elem.dragStatus = 'stopped';\n    }\n    DD._endDragBefore(evt);\n    DD._endDragAfter(evt);\n  }\n  setDraggable(draggable) {\n    this._setAttr('draggable', draggable);\n    this._dragChange();\n  }\n  isDragging() {\n    const elem = DD._dragElements.get(this._id);\n    return elem ? elem.dragStatus === 'dragging' : false;\n  }\n  _listenDrag() {\n    this._dragCleanup();\n    this.on('mousedown.konva touchstart.konva', function (evt) {\n      var shouldCheckButton = evt.evt['button'] !== undefined;\n      var canDrag = !shouldCheckButton || Konva.dragButtons.indexOf(evt.evt['button']) >= 0;\n      if (!canDrag) {\n        return;\n      }\n      if (this.isDragging()) {\n        return;\n      }\n      var hasDraggingChild = false;\n      DD._dragElements.forEach(elem => {\n        if (this.isAncestorOf(elem.node)) {\n          hasDraggingChild = true;\n        }\n      });\n      if (!hasDraggingChild) {\n        this._createDragElement(evt);\n      }\n    });\n  }\n  _dragChange() {\n    if (this.attrs.draggable) {\n      this._listenDrag();\n    } else {\n      this._dragCleanup();\n      var stage = this.getStage();\n      if (!stage) {\n        return;\n      }\n      const dragElement = DD._dragElements.get(this._id);\n      const isDragging = dragElement && dragElement.dragStatus === 'dragging';\n      const isReady = dragElement && dragElement.dragStatus === 'ready';\n      if (isDragging) {\n        this.stopDrag();\n      } else if (isReady) {\n        DD._dragElements.delete(this._id);\n      }\n    }\n  }\n  _dragCleanup() {\n    this.off('mousedown.konva');\n    this.off('touchstart.konva');\n  }\n  isClientRectOnScreen() {\n    let margin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      x: 0,\n      y: 0\n    };\n    const stage = this.getStage();\n    if (!stage) {\n      return false;\n    }\n    const screenRect = {\n      x: -margin.x,\n      y: -margin.y,\n      width: stage.width() + 2 * margin.x,\n      height: stage.height() + 2 * margin.y\n    };\n    return Util.haveIntersection(screenRect, this.getClientRect());\n  }\n  static create(data, container) {\n    if (Util._isString(data)) {\n      data = JSON.parse(data);\n    }\n    return this._createNode(data, container);\n  }\n  static _createNode(obj, container) {\n    var className = Node.prototype.getClassName.call(obj),\n      children = obj.children,\n      no,\n      len,\n      n;\n    if (container) {\n      obj.attrs.container = container;\n    }\n    if (!Konva[className]) {\n      Util.warn('Can not find a node with class name \"' + className + '\". Fallback to \"Shape\".');\n      className = 'Shape';\n    }\n    const Class = Konva[className];\n    no = new Class(obj.attrs);\n    if (children) {\n      len = children.length;\n      for (n = 0; n < len; n++) {\n        no.add(Node._createNode(children[n]));\n      }\n    }\n    return no;\n  }\n}\nNode.prototype.nodeType = 'Node';\nNode.prototype._attrsAffectingSize = [];\nNode.prototype.eventListeners = {};\nNode.prototype.on.call(Node.prototype, TRANSFORM_CHANGE_STR, function () {\n  if (this._batchingTransformChange) {\n    this._needClearTransformCache = true;\n    return;\n  }\n  this._clearCache(TRANSFORM);\n  this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\n});\nNode.prototype.on.call(Node.prototype, 'visibleChange.konva', function () {\n  this._clearSelfAndDescendantCache(VISIBLE);\n});\nNode.prototype.on.call(Node.prototype, 'listeningChange.konva', function () {\n  this._clearSelfAndDescendantCache(LISTENING);\n});\nNode.prototype.on.call(Node.prototype, 'opacityChange.konva', function () {\n  this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\n});\nconst addGetterSetter = Factory.addGetterSetter;\naddGetterSetter(Node, 'zIndex');\naddGetterSetter(Node, 'absolutePosition');\naddGetterSetter(Node, 'position');\naddGetterSetter(Node, 'x', 0, getNumberValidator());\naddGetterSetter(Node, 'y', 0, getNumberValidator());\naddGetterSetter(Node, 'globalCompositeOperation', 'source-over', getStringValidator());\naddGetterSetter(Node, 'opacity', 1, getNumberValidator());\naddGetterSetter(Node, 'name', '', getStringValidator());\naddGetterSetter(Node, 'id', '', getStringValidator());\naddGetterSetter(Node, 'rotation', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Node, 'scale', ['x', 'y']);\naddGetterSetter(Node, 'scaleX', 1, getNumberValidator());\naddGetterSetter(Node, 'scaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Node, 'skew', ['x', 'y']);\naddGetterSetter(Node, 'skewX', 0, getNumberValidator());\naddGetterSetter(Node, 'skewY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Node, 'offset', ['x', 'y']);\naddGetterSetter(Node, 'offsetX', 0, getNumberValidator());\naddGetterSetter(Node, 'offsetY', 0, getNumberValidator());\naddGetterSetter(Node, 'dragDistance', null, getNumberValidator());\naddGetterSetter(Node, 'width', 0, getNumberValidator());\naddGetterSetter(Node, 'height', 0, getNumberValidator());\naddGetterSetter(Node, 'listening', true, getBooleanValidator());\naddGetterSetter(Node, 'preventDefault', true, getBooleanValidator());\naddGetterSetter(Node, 'filters', null, function (val) {\n  this._filterUpToDate = false;\n  return val;\n});\naddGetterSetter(Node, 'visible', true, getBooleanValidator());\naddGetterSetter(Node, 'transformsEnabled', 'all', getStringValidator());\naddGetterSetter(Node, 'size');\naddGetterSetter(Node, 'dragBoundFunc');\naddGetterSetter(Node, 'draggable', false, getBooleanValidator());\nFactory.backCompat(Node, {\n  rotateDeg: 'rotate',\n  setRotationDeg: 'setRotation',\n  getRotationDeg: 'getRotation'\n});","map":null,"metadata":{},"sourceType":"module"}