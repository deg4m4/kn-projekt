{"ast":null,"code":"import { Util } from './Util.js';\nimport { Konva } from './Global.js';\nfunction simplifyArray(arr) {\n  var retArr = [],\n    len = arr.length,\n    util = Util,\n    n,\n    val;\n  for (n = 0; n < len; n++) {\n    val = arr[n];\n    if (util._isNumber(val)) {\n      val = Math.round(val * 1000) / 1000;\n    } else if (!util._isString(val)) {\n      val = val + '';\n    }\n    retArr.push(val);\n  }\n  return retArr;\n}\nvar COMMA = ',',\n  OPEN_PAREN = '(',\n  CLOSE_PAREN = ')',\n  OPEN_PAREN_BRACKET = '([',\n  CLOSE_BRACKET_PAREN = '])',\n  SEMICOLON = ';',\n  DOUBLE_PAREN = '()',\n  EQUALS = '=',\n  CONTEXT_METHODS = ['arc', 'arcTo', 'beginPath', 'bezierCurveTo', 'clearRect', 'clip', 'closePath', 'createLinearGradient', 'createPattern', 'createRadialGradient', 'drawImage', 'ellipse', 'fill', 'fillText', 'getImageData', 'createImageData', 'lineTo', 'moveTo', 'putImageData', 'quadraticCurveTo', 'rect', 'restore', 'rotate', 'save', 'scale', 'setLineDash', 'setTransform', 'stroke', 'strokeText', 'transform', 'translate'];\nvar CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'lineCap', 'lineDashOffset', 'lineJoin', 'lineWidth', 'miterLimit', 'font', 'textAlign', 'textBaseline', 'globalAlpha', 'globalCompositeOperation', 'imageSmoothingEnabled'];\nconst traceArrMax = 100;\nexport class Context {\n  constructor(canvas) {\n    this.canvas = canvas;\n    if (Konva.enableTrace) {\n      this.traceArr = [];\n      this._enableTrace();\n    }\n  }\n  fillShape(shape) {\n    if (shape.fillEnabled()) {\n      this._fill(shape);\n    }\n  }\n  _fill(shape) {}\n  strokeShape(shape) {\n    if (shape.hasStroke()) {\n      this._stroke(shape);\n    }\n  }\n  _stroke(shape) {}\n  fillStrokeShape(shape) {\n    if (shape.attrs.fillAfterStrokeEnabled) {\n      this.strokeShape(shape);\n      this.fillShape(shape);\n    } else {\n      this.fillShape(shape);\n      this.strokeShape(shape);\n    }\n  }\n  getTrace(relaxed, rounded) {\n    var traceArr = this.traceArr,\n      len = traceArr.length,\n      str = '',\n      n,\n      trace,\n      method,\n      args;\n    for (n = 0; n < len; n++) {\n      trace = traceArr[n];\n      method = trace.method;\n      if (method) {\n        args = trace.args;\n        str += method;\n        if (relaxed) {\n          str += DOUBLE_PAREN;\n        } else {\n          if (Util._isArray(args[0])) {\n            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\n          } else {\n            if (rounded) {\n              args = args.map(a => typeof a === 'number' ? Math.floor(a) : a);\n            }\n            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\n          }\n        }\n      } else {\n        str += trace.property;\n        if (!relaxed) {\n          str += EQUALS + trace.val;\n        }\n      }\n      str += SEMICOLON;\n    }\n    return str;\n  }\n  clearTrace() {\n    this.traceArr = [];\n  }\n  _trace(str) {\n    var traceArr = this.traceArr,\n      len;\n    traceArr.push(str);\n    len = traceArr.length;\n    if (len >= traceArrMax) {\n      traceArr.shift();\n    }\n  }\n  reset() {\n    var pixelRatio = this.getCanvas().getPixelRatio();\n    this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\n  }\n  getCanvas() {\n    return this.canvas;\n  }\n  clear(bounds) {\n    var canvas = this.getCanvas();\n    if (bounds) {\n      this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\n    } else {\n      this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\n    }\n  }\n  _applyLineCap(shape) {\n    var lineCap = shape.getLineCap();\n    if (lineCap) {\n      this.setAttr('lineCap', lineCap);\n    }\n  }\n  _applyOpacity(shape) {\n    var absOpacity = shape.getAbsoluteOpacity();\n    if (absOpacity !== 1) {\n      this.setAttr('globalAlpha', absOpacity);\n    }\n  }\n  _applyLineJoin(shape) {\n    var lineJoin = shape.attrs.lineJoin;\n    if (lineJoin) {\n      this.setAttr('lineJoin', lineJoin);\n    }\n  }\n  setAttr(attr, val) {\n    this._context[attr] = val;\n  }\n  arc(a0, a1, a2, a3, a4, a5) {\n    this._context.arc(a0, a1, a2, a3, a4, a5);\n  }\n  arcTo(a0, a1, a2, a3, a4) {\n    this._context.arcTo(a0, a1, a2, a3, a4);\n  }\n  beginPath() {\n    this._context.beginPath();\n  }\n  bezierCurveTo(a0, a1, a2, a3, a4, a5) {\n    this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);\n  }\n  clearRect(a0, a1, a2, a3) {\n    this._context.clearRect(a0, a1, a2, a3);\n  }\n  clip() {\n    this._context.clip();\n  }\n  closePath() {\n    this._context.closePath();\n  }\n  createImageData(a0, a1) {\n    var a = arguments;\n    if (a.length === 2) {\n      return this._context.createImageData(a0, a1);\n    } else if (a.length === 1) {\n      return this._context.createImageData(a0);\n    }\n  }\n  createLinearGradient(a0, a1, a2, a3) {\n    return this._context.createLinearGradient(a0, a1, a2, a3);\n  }\n  createPattern(a0, a1) {\n    return this._context.createPattern(a0, a1);\n  }\n  createRadialGradient(a0, a1, a2, a3, a4, a5) {\n    return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);\n  }\n  drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n    var a = arguments,\n      _context = this._context;\n    if (a.length === 3) {\n      _context.drawImage(a0, a1, a2);\n    } else if (a.length === 5) {\n      _context.drawImage(a0, a1, a2, a3, a4);\n    } else if (a.length === 9) {\n      _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n    }\n  }\n  ellipse(a0, a1, a2, a3, a4, a5, a6, a7) {\n    this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);\n  }\n  isPointInPath(x, y, path, fillRule) {\n    if (path) {\n      return this._context.isPointInPath(path, x, y, fillRule);\n    }\n    return this._context.isPointInPath(x, y, fillRule);\n  }\n  fill(path2d) {\n    if (path2d) {\n      this._context.fill(path2d);\n    } else {\n      this._context.fill();\n    }\n  }\n  fillRect(x, y, width, height) {\n    this._context.fillRect(x, y, width, height);\n  }\n  strokeRect(x, y, width, height) {\n    this._context.strokeRect(x, y, width, height);\n  }\n  fillText(text, x, y, maxWidth) {\n    if (maxWidth) {\n      this._context.fillText(text, x, y, maxWidth);\n    } else {\n      this._context.fillText(text, x, y);\n    }\n  }\n  measureText(text) {\n    return this._context.measureText(text);\n  }\n  getImageData(a0, a1, a2, a3) {\n    return this._context.getImageData(a0, a1, a2, a3);\n  }\n  lineTo(a0, a1) {\n    this._context.lineTo(a0, a1);\n  }\n  moveTo(a0, a1) {\n    this._context.moveTo(a0, a1);\n  }\n  rect(a0, a1, a2, a3) {\n    this._context.rect(a0, a1, a2, a3);\n  }\n  putImageData(a0, a1, a2) {\n    this._context.putImageData(a0, a1, a2);\n  }\n  quadraticCurveTo(a0, a1, a2, a3) {\n    this._context.quadraticCurveTo(a0, a1, a2, a3);\n  }\n  restore() {\n    this._context.restore();\n  }\n  rotate(a0) {\n    this._context.rotate(a0);\n  }\n  save() {\n    this._context.save();\n  }\n  scale(a0, a1) {\n    this._context.scale(a0, a1);\n  }\n  setLineDash(a0) {\n    if (this._context.setLineDash) {\n      this._context.setLineDash(a0);\n    } else if ('mozDash' in this._context) {\n      this._context['mozDash'] = a0;\n    } else if ('webkitLineDash' in this._context) {\n      this._context['webkitLineDash'] = a0;\n    }\n  }\n  getLineDash() {\n    return this._context.getLineDash();\n  }\n  setTransform(a0, a1, a2, a3, a4, a5) {\n    this._context.setTransform(a0, a1, a2, a3, a4, a5);\n  }\n  stroke(path2d) {\n    if (path2d) {\n      this._context.stroke(path2d);\n    } else {\n      this._context.stroke();\n    }\n  }\n  strokeText(a0, a1, a2, a3) {\n    this._context.strokeText(a0, a1, a2, a3);\n  }\n  transform(a0, a1, a2, a3, a4, a5) {\n    this._context.transform(a0, a1, a2, a3, a4, a5);\n  }\n  translate(a0, a1) {\n    this._context.translate(a0, a1);\n  }\n  _enableTrace() {\n    var that = this,\n      len = CONTEXT_METHODS.length,\n      origSetter = this.setAttr,\n      n,\n      args;\n    var func = function (methodName) {\n      var origMethod = that[methodName],\n        ret;\n      that[methodName] = function () {\n        args = simplifyArray(Array.prototype.slice.call(arguments, 0));\n        ret = origMethod.apply(that, arguments);\n        that._trace({\n          method: methodName,\n          args: args\n        });\n        return ret;\n      };\n    };\n    for (n = 0; n < len; n++) {\n      func(CONTEXT_METHODS[n]);\n    }\n    that.setAttr = function () {\n      origSetter.apply(that, arguments);\n      var prop = arguments[0];\n      var val = arguments[1];\n      if (prop === 'shadowOffsetX' || prop === 'shadowOffsetY' || prop === 'shadowBlur') {\n        val = val / this.canvas.getPixelRatio();\n      }\n      that._trace({\n        property: prop,\n        val: val\n      });\n    };\n  }\n  _applyGlobalCompositeOperation(node) {\n    const op = node.attrs.globalCompositeOperation;\n    var def = !op || op === 'source-over';\n    if (!def) {\n      this.setAttr('globalCompositeOperation', op);\n    }\n  }\n}\nCONTEXT_PROPERTIES.forEach(function (prop) {\n  Object.defineProperty(Context.prototype, prop, {\n    get() {\n      return this._context[prop];\n    },\n    set(val) {\n      this._context[prop] = val;\n    }\n  });\n});\nexport class SceneContext extends Context {\n  constructor(canvas) {\n    super(canvas);\n    this._context = canvas._canvas.getContext('2d');\n  }\n  _fillColor(shape) {\n    var fill = shape.fill();\n    this.setAttr('fillStyle', fill);\n    shape._fillFunc(this);\n  }\n  _fillPattern(shape) {\n    this.setAttr('fillStyle', shape._getFillPattern());\n    shape._fillFunc(this);\n  }\n  _fillLinearGradient(shape) {\n    var grd = shape._getLinearGradient();\n    if (grd) {\n      this.setAttr('fillStyle', grd);\n      shape._fillFunc(this);\n    }\n  }\n  _fillRadialGradient(shape) {\n    var grd = shape._getRadialGradient();\n    if (grd) {\n      this.setAttr('fillStyle', grd);\n      shape._fillFunc(this);\n    }\n  }\n  _fill(shape) {\n    var hasColor = shape.fill(),\n      fillPriority = shape.getFillPriority();\n    if (hasColor && fillPriority === 'color') {\n      this._fillColor(shape);\n      return;\n    }\n    var hasPattern = shape.getFillPatternImage();\n    if (hasPattern && fillPriority === 'pattern') {\n      this._fillPattern(shape);\n      return;\n    }\n    var hasLinearGradient = shape.getFillLinearGradientColorStops();\n    if (hasLinearGradient && fillPriority === 'linear-gradient') {\n      this._fillLinearGradient(shape);\n      return;\n    }\n    var hasRadialGradient = shape.getFillRadialGradientColorStops();\n    if (hasRadialGradient && fillPriority === 'radial-gradient') {\n      this._fillRadialGradient(shape);\n      return;\n    }\n    if (hasColor) {\n      this._fillColor(shape);\n    } else if (hasPattern) {\n      this._fillPattern(shape);\n    } else if (hasLinearGradient) {\n      this._fillLinearGradient(shape);\n    } else if (hasRadialGradient) {\n      this._fillRadialGradient(shape);\n    }\n  }\n  _strokeLinearGradient(shape) {\n    var start = shape.getStrokeLinearGradientStartPoint(),\n      end = shape.getStrokeLinearGradientEndPoint(),\n      colorStops = shape.getStrokeLinearGradientColorStops(),\n      grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\n    if (colorStops) {\n      for (var n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n      this.setAttr('strokeStyle', grd);\n    }\n  }\n  _stroke(shape) {\n    var dash = shape.dash(),\n      strokeScaleEnabled = shape.getStrokeScaleEnabled();\n    if (shape.hasStroke()) {\n      if (!strokeScaleEnabled) {\n        this.save();\n        var pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n      }\n      this._applyLineCap(shape);\n      if (dash && shape.dashEnabled()) {\n        this.setLineDash(dash);\n        this.setAttr('lineDashOffset', shape.dashOffset());\n      }\n      this.setAttr('lineWidth', shape.strokeWidth());\n      if (!shape.getShadowForStrokeEnabled()) {\n        this.setAttr('shadowColor', 'rgba(0,0,0,0)');\n      }\n      var hasLinearGradient = shape.getStrokeLinearGradientColorStops();\n      if (hasLinearGradient) {\n        this._strokeLinearGradient(shape);\n      } else {\n        this.setAttr('strokeStyle', shape.stroke());\n      }\n      shape._strokeFunc(this);\n      if (!strokeScaleEnabled) {\n        this.restore();\n      }\n    }\n  }\n  _applyShadow(shape) {\n    var _a, _b, _c;\n    var color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black',\n      blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5,\n      offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {\n        x: 0,\n        y: 0\n      },\n      scale = shape.getAbsoluteScale(),\n      ratio = this.canvas.getPixelRatio(),\n      scaleX = scale.x * ratio,\n      scaleY = scale.y * ratio;\n    this.setAttr('shadowColor', color);\n    this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\n    this.setAttr('shadowOffsetX', offset.x * scaleX);\n    this.setAttr('shadowOffsetY', offset.y * scaleY);\n  }\n}\nexport class HitContext extends Context {\n  constructor(canvas) {\n    super(canvas);\n    this._context = canvas._canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n  }\n  _fill(shape) {\n    this.save();\n    this.setAttr('fillStyle', shape.colorKey);\n    shape._fillFuncHit(this);\n    this.restore();\n  }\n  strokeShape(shape) {\n    if (shape.hasHitStroke()) {\n      this._stroke(shape);\n    }\n  }\n  _stroke(shape) {\n    if (shape.hasHitStroke()) {\n      var strokeScaleEnabled = shape.getStrokeScaleEnabled();\n      if (!strokeScaleEnabled) {\n        this.save();\n        var pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n      }\n      this._applyLineCap(shape);\n      var hitStrokeWidth = shape.hitStrokeWidth();\n      var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\n      this.setAttr('lineWidth', strokeWidth);\n      this.setAttr('strokeStyle', shape.colorKey);\n      shape._strokeFuncHit(this);\n      if (!strokeScaleEnabled) {\n        this.restore();\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}