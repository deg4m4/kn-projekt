{"ast":null,"code":"import { Factory } from './Factory.js';\nimport { Node } from './Node.js';\nimport { getNumberValidator } from './Validators.js';\nexport class Container extends Node {\n  constructor() {\n    super(...arguments);\n    this.children = [];\n  }\n  getChildren(filterFunc) {\n    if (!filterFunc) {\n      return this.children || [];\n    }\n    const children = this.children || [];\n    var results = [];\n    children.forEach(function (child) {\n      if (filterFunc(child)) {\n        results.push(child);\n      }\n    });\n    return results;\n  }\n  hasChildren() {\n    return this.getChildren().length > 0;\n  }\n  removeChildren() {\n    this.getChildren().forEach(child => {\n      child.parent = null;\n      child.index = 0;\n      child.remove();\n    });\n    this.children = [];\n    this._requestDraw();\n    return this;\n  }\n  destroyChildren() {\n    this.getChildren().forEach(child => {\n      child.parent = null;\n      child.index = 0;\n      child.destroy();\n    });\n    this.children = [];\n    this._requestDraw();\n    return this;\n  }\n  add() {\n    if (arguments.length === 0) {\n      return this;\n    }\n    if (arguments.length > 1) {\n      for (var i = 0; i < arguments.length; i++) {\n        this.add(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      }\n      return this;\n    }\n    const child = arguments.length <= 0 ? undefined : arguments[0];\n    if (child.getParent()) {\n      child.moveTo(this);\n      return this;\n    }\n    this._validateAdd(child);\n    child.index = this.getChildren().length;\n    child.parent = this;\n    child._clearCaches();\n    this.getChildren().push(child);\n    this._fire('add', {\n      child: child\n    });\n    this._requestDraw();\n    return this;\n  }\n  destroy() {\n    if (this.hasChildren()) {\n      this.destroyChildren();\n    }\n    super.destroy();\n    return this;\n  }\n  find(selector) {\n    return this._generalFind(selector, false);\n  }\n  findOne(selector) {\n    var result = this._generalFind(selector, true);\n    return result.length > 0 ? result[0] : undefined;\n  }\n  _generalFind(selector, findOne) {\n    var retArr = [];\n    this._descendants(node => {\n      const valid = node._isMatch(selector);\n      if (valid) {\n        retArr.push(node);\n      }\n      if (valid && findOne) {\n        return true;\n      }\n      return false;\n    });\n    return retArr;\n  }\n  _descendants(fn) {\n    let shouldStop = false;\n    const children = this.getChildren();\n    for (const child of children) {\n      shouldStop = fn(child);\n      if (shouldStop) {\n        return true;\n      }\n      if (!child.hasChildren()) {\n        continue;\n      }\n      shouldStop = child._descendants(fn);\n      if (shouldStop) {\n        return true;\n      }\n    }\n    return false;\n  }\n  toObject() {\n    var obj = Node.prototype.toObject.call(this);\n    obj.children = [];\n    this.getChildren().forEach(child => {\n      obj.children.push(child.toObject());\n    });\n    return obj;\n  }\n  isAncestorOf(node) {\n    var parent = node.getParent();\n    while (parent) {\n      if (parent._id === this._id) {\n        return true;\n      }\n      parent = parent.getParent();\n    }\n    return false;\n  }\n  clone(obj) {\n    var node = Node.prototype.clone.call(this, obj);\n    this.getChildren().forEach(function (no) {\n      node.add(no.clone());\n    });\n    return node;\n  }\n  getAllIntersections(pos) {\n    var arr = [];\n    this.find('Shape').forEach(function (shape) {\n      if (shape.isVisible() && shape.intersects(pos)) {\n        arr.push(shape);\n      }\n    });\n    return arr;\n  }\n  _clearSelfAndDescendantCache(attr) {\n    var _a;\n    super._clearSelfAndDescendantCache(attr);\n    if (this.isCached()) {\n      return;\n    }\n    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {\n      node._clearSelfAndDescendantCache(attr);\n    });\n  }\n  _setChildrenIndices() {\n    var _a;\n    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child, n) {\n      child.index = n;\n    });\n    this._requestDraw();\n  }\n  drawScene(can, top) {\n    var layer = this.getLayer(),\n      canvas = can || layer && layer.getCanvas(),\n      context = canvas && canvas.getContext(),\n      cachedCanvas = this._getCanvasCache(),\n      cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;\n    var caching = canvas && canvas.isCache;\n    if (!this.isVisible() && !caching) {\n      return this;\n    }\n    if (cachedSceneCanvas) {\n      context.save();\n      var m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n      this._drawCachedSceneCanvas(context);\n      context.restore();\n    } else {\n      this._drawChildren('drawScene', canvas, top);\n    }\n    return this;\n  }\n  drawHit(can, top) {\n    if (!this.shouldDrawHit(top)) {\n      return this;\n    }\n    var layer = this.getLayer(),\n      canvas = can || layer && layer.hitCanvas,\n      context = canvas && canvas.getContext(),\n      cachedCanvas = this._getCanvasCache(),\n      cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n    if (cachedHitCanvas) {\n      context.save();\n      var m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n      this._drawCachedHitCanvas(context);\n      context.restore();\n    } else {\n      this._drawChildren('drawHit', canvas, top);\n    }\n    return this;\n  }\n  _drawChildren(drawMethod, canvas, top) {\n    var _a;\n    var context = canvas && canvas.getContext(),\n      clipWidth = this.clipWidth(),\n      clipHeight = this.clipHeight(),\n      clipFunc = this.clipFunc(),\n      hasClip = clipWidth && clipHeight || clipFunc;\n    const selfCache = top === this;\n    if (hasClip) {\n      context.save();\n      var transform = this.getAbsoluteTransform(top);\n      var m = transform.getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n      context.beginPath();\n      if (clipFunc) {\n        clipFunc.call(this, context, this);\n      } else {\n        var clipX = this.clipX();\n        var clipY = this.clipY();\n        context.rect(clipX, clipY, clipWidth, clipHeight);\n      }\n      context.clip();\n      m = transform.copy().invert().getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n    }\n    var hasComposition = !selfCache && this.globalCompositeOperation() !== 'source-over' && drawMethod === 'drawScene';\n    if (hasComposition) {\n      context.save();\n      context._applyGlobalCompositeOperation(this);\n    }\n    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      child[drawMethod](canvas, top);\n    });\n    if (hasComposition) {\n      context.restore();\n    }\n    if (hasClip) {\n      context.restore();\n    }\n  }\n  getClientRect(config) {\n    var _a;\n    config = config || {};\n    var skipTransform = config.skipTransform;\n    var relativeTo = config.relativeTo;\n    var minX, minY, maxX, maxY;\n    var selfRect = {\n      x: Infinity,\n      y: Infinity,\n      width: 0,\n      height: 0\n    };\n    var that = this;\n    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      if (!child.visible()) {\n        return;\n      }\n      var rect = child.getClientRect({\n        relativeTo: that,\n        skipShadow: config.skipShadow,\n        skipStroke: config.skipStroke\n      });\n      if (rect.width === 0 && rect.height === 0) {\n        return;\n      }\n      if (minX === undefined) {\n        minX = rect.x;\n        minY = rect.y;\n        maxX = rect.x + rect.width;\n        maxY = rect.y + rect.height;\n      } else {\n        minX = Math.min(minX, rect.x);\n        minY = Math.min(minY, rect.y);\n        maxX = Math.max(maxX, rect.x + rect.width);\n        maxY = Math.max(maxY, rect.y + rect.height);\n      }\n    });\n    var shapes = this.find('Shape');\n    var hasVisible = false;\n    for (var i = 0; i < shapes.length; i++) {\n      var shape = shapes[i];\n      if (shape._isVisible(this)) {\n        hasVisible = true;\n        break;\n      }\n    }\n    if (hasVisible && minX !== undefined) {\n      selfRect = {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n      };\n    } else {\n      selfRect = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n    if (!skipTransform) {\n      return this._transformedRect(selfRect, relativeTo);\n    }\n    return selfRect;\n  }\n}\nFactory.addComponentsGetterSetter(Container, 'clip', ['x', 'y', 'width', 'height']);\nFactory.addGetterSetter(Container, 'clipX', undefined, getNumberValidator());\nFactory.addGetterSetter(Container, 'clipY', undefined, getNumberValidator());\nFactory.addGetterSetter(Container, 'clipWidth', undefined, getNumberValidator());\nFactory.addGetterSetter(Container, 'clipHeight', undefined, getNumberValidator());\nFactory.addGetterSetter(Container, 'clipFunc');","map":null,"metadata":{},"sourceType":"module"}