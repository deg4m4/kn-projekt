{"ast":null,"code":"import { Konva } from './Global.js';\nimport { Util } from './Util.js';\nexport const DD = {\n  get isDragging() {\n    var flag = false;\n    DD._dragElements.forEach(elem => {\n      if (elem.dragStatus === 'dragging') {\n        flag = true;\n      }\n    });\n    return flag;\n  },\n  justDragged: false,\n  get node() {\n    var node;\n    DD._dragElements.forEach(elem => {\n      node = elem.node;\n    });\n    return node;\n  },\n  _dragElements: new Map(),\n  _drag(evt) {\n    const nodesToFireEvents = [];\n    DD._dragElements.forEach((elem, key) => {\n      const {\n        node\n      } = elem;\n      const stage = node.getStage();\n      stage.setPointersPositions(evt);\n      if (elem.pointerId === undefined) {\n        elem.pointerId = Util._getFirstPointerId(evt);\n      }\n      const pos = stage._changedPointerPositions.find(pos => pos.id === elem.pointerId);\n      if (!pos) {\n        return;\n      }\n      if (elem.dragStatus !== 'dragging') {\n        var dragDistance = node.dragDistance();\n        var distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));\n        if (distance < dragDistance) {\n          return;\n        }\n        node.startDrag({\n          evt\n        });\n        if (!node.isDragging()) {\n          return;\n        }\n      }\n      node._setDragPosition(evt, elem);\n      nodesToFireEvents.push(node);\n    });\n    nodesToFireEvents.forEach(node => {\n      node.fire('dragmove', {\n        type: 'dragmove',\n        target: node,\n        evt: evt\n      }, true);\n    });\n  },\n  _endDragBefore(evt) {\n    const drawNodes = [];\n    DD._dragElements.forEach(elem => {\n      const {\n        node\n      } = elem;\n      const stage = node.getStage();\n      if (evt) {\n        stage.setPointersPositions(evt);\n      }\n      const pos = stage._changedPointerPositions.find(pos => pos.id === elem.pointerId);\n      if (!pos) {\n        return;\n      }\n      if (elem.dragStatus === 'dragging' || elem.dragStatus === 'stopped') {\n        DD.justDragged = true;\n        Konva._mouseListenClick = false;\n        Konva._touchListenClick = false;\n        Konva._pointerListenClick = false;\n        elem.dragStatus = 'stopped';\n      }\n      const drawNode = elem.node.getLayer() || elem.node instanceof Konva['Stage'] && elem.node;\n      if (drawNode && drawNodes.indexOf(drawNode) === -1) {\n        drawNodes.push(drawNode);\n      }\n    });\n    drawNodes.forEach(drawNode => {\n      drawNode.draw();\n    });\n  },\n  _endDragAfter(evt) {\n    DD._dragElements.forEach((elem, key) => {\n      if (elem.dragStatus === 'stopped') {\n        elem.node.fire('dragend', {\n          type: 'dragend',\n          target: elem.node,\n          evt: evt\n        }, true);\n      }\n      if (elem.dragStatus !== 'dragging') {\n        DD._dragElements.delete(key);\n      }\n    });\n  }\n};\nif (Konva.isBrowser) {\n  window.addEventListener('mouseup', DD._endDragBefore, true);\n  window.addEventListener('touchend', DD._endDragBefore, true);\n  window.addEventListener('mousemove', DD._drag);\n  window.addEventListener('touchmove', DD._drag);\n  window.addEventListener('mouseup', DD._endDragAfter, false);\n  window.addEventListener('touchend', DD._endDragAfter, false);\n}","map":null,"metadata":{},"sourceType":"module"}