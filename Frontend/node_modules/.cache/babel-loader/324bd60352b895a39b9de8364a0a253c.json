{"ast":null,"code":"import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage',\n  STRING = 'string',\n  PX = 'px',\n  MOUSEOUT = 'mouseout',\n  MOUSELEAVE = 'mouseleave',\n  MOUSEOVER = 'mouseover',\n  MOUSEENTER = 'mouseenter',\n  MOUSEMOVE = 'mousemove',\n  MOUSEDOWN = 'mousedown',\n  MOUSEUP = 'mouseup',\n  POINTERMOVE = 'pointermove',\n  POINTERDOWN = 'pointerdown',\n  POINTERUP = 'pointerup',\n  POINTERCANCEL = 'pointercancel',\n  LOSTPOINTERCAPTURE = 'lostpointercapture',\n  POINTEROUT = 'pointerout',\n  POINTERLEAVE = 'pointerleave',\n  POINTEROVER = 'pointerover',\n  POINTERENTER = 'pointerenter',\n  CONTEXTMENU = 'contextmenu',\n  TOUCHSTART = 'touchstart',\n  TOUCHEND = 'touchend',\n  TOUCHMOVE = 'touchmove',\n  TOUCHCANCEL = 'touchcancel',\n  WHEEL = 'wheel',\n  MAX_LAYERS_NUMBER = 5,\n  EVENTS = [[MOUSEENTER, '_pointerenter'], [MOUSEDOWN, '_pointerdown'], [MOUSEMOVE, '_pointermove'], [MOUSEUP, '_pointerup'], [MOUSELEAVE, '_pointerleave'], [TOUCHSTART, '_pointerdown'], [TOUCHMOVE, '_pointermove'], [TOUCHEND, '_pointerup'], [TOUCHCANCEL, '_pointercancel'], [MOUSEOVER, '_pointerover'], [WHEEL, '_wheel'], [CONTEXTMENU, '_contextmenu'], [POINTERDOWN, '_pointerdown'], [POINTERMOVE, '_pointermove'], [POINTERUP, '_pointerup'], [POINTERCANCEL, '_pointercancel'], [LOSTPOINTERCAPTURE, '_lostpointercapture']];\nconst EVENTS_MAP = {\n  mouse: {\n    [POINTEROUT]: MOUSEOUT,\n    [POINTERLEAVE]: MOUSELEAVE,\n    [POINTEROVER]: MOUSEOVER,\n    [POINTERENTER]: MOUSEENTER,\n    [POINTERMOVE]: MOUSEMOVE,\n    [POINTERDOWN]: MOUSEDOWN,\n    [POINTERUP]: MOUSEUP,\n    [POINTERCANCEL]: 'mousecancel',\n    pointerclick: 'click',\n    pointerdblclick: 'dblclick'\n  },\n  touch: {\n    [POINTEROUT]: 'touchout',\n    [POINTERLEAVE]: 'touchleave',\n    [POINTEROVER]: 'touchover',\n    [POINTERENTER]: 'touchenter',\n    [POINTERMOVE]: TOUCHMOVE,\n    [POINTERDOWN]: TOUCHSTART,\n    [POINTERUP]: TOUCHEND,\n    [POINTERCANCEL]: TOUCHCANCEL,\n    pointerclick: 'tap',\n    pointerdblclick: 'dbltap'\n  },\n  pointer: {\n    [POINTEROUT]: POINTEROUT,\n    [POINTERLEAVE]: POINTERLEAVE,\n    [POINTEROVER]: POINTEROVER,\n    [POINTERENTER]: POINTERENTER,\n    [POINTERMOVE]: POINTERMOVE,\n    [POINTERDOWN]: POINTERDOWN,\n    [POINTERUP]: POINTERUP,\n    [POINTERCANCEL]: POINTERCANCEL,\n    pointerclick: 'pointerclick',\n    pointerdblclick: 'pointerdblclick'\n  }\n};\nconst getEventType = type => {\n  if (type.indexOf('pointer') >= 0) {\n    return 'pointer';\n  }\n  if (type.indexOf('touch') >= 0) {\n    return 'touch';\n  }\n  return 'mouse';\n};\nconst getEventsMap = eventType => {\n  const type = getEventType(eventType);\n  if (type === 'pointer') {\n    return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n  }\n  if (type === 'touch') {\n    return EVENTS_MAP.touch;\n  }\n  if (type === 'mouse') {\n    return EVENTS_MAP.mouse;\n  }\n};\nfunction checkNoClip() {\n  let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n    Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n  }\n  return attrs;\n}\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n  constructor(config) {\n    super(checkNoClip(config));\n    this._pointerPositions = [];\n    this._changedPointerPositions = [];\n    this._buildDOM();\n    this._bindContentEvents();\n    stages.push(this);\n    this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n    this.on('visibleChange.konva', this._checkVisibility);\n    this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n      checkNoClip(this.attrs);\n    });\n    this._checkVisibility();\n  }\n  _validateAdd(child) {\n    const isLayer = child.getType() === 'Layer';\n    const isFastLayer = child.getType() === 'FastLayer';\n    const valid = isLayer || isFastLayer;\n    if (!valid) {\n      Util.throw('You may only add layers to the stage.');\n    }\n  }\n  _checkVisibility() {\n    if (!this.content) {\n      return;\n    }\n    const style = this.visible() ? '' : 'none';\n    this.content.style.display = style;\n  }\n  setContainer(container) {\n    if (typeof container === STRING) {\n      if (container.charAt(0) === '.') {\n        var className = container.slice(1);\n        container = document.getElementsByClassName(className)[0];\n      } else {\n        var id;\n        if (container.charAt(0) !== '#') {\n          id = container;\n        } else {\n          id = container.slice(1);\n        }\n        container = document.getElementById(id);\n      }\n      if (!container) {\n        throw 'Can not find container in document with id ' + id;\n      }\n    }\n    this._setAttr('container', container);\n    if (this.content) {\n      if (this.content.parentElement) {\n        this.content.parentElement.removeChild(this.content);\n      }\n      container.appendChild(this.content);\n    }\n    return this;\n  }\n  shouldDrawHit() {\n    return true;\n  }\n  clear() {\n    var layers = this.children,\n      len = layers.length,\n      n;\n    for (n = 0; n < len; n++) {\n      layers[n].clear();\n    }\n    return this;\n  }\n  clone(obj) {\n    if (!obj) {\n      obj = {};\n    }\n    obj.container = typeof document !== 'undefined' && document.createElement('div');\n    return Container.prototype.clone.call(this, obj);\n  }\n  destroy() {\n    super.destroy();\n    var content = this.content;\n    if (content && Util._isInDocument(content)) {\n      this.container().removeChild(content);\n    }\n    var index = stages.indexOf(this);\n    if (index > -1) {\n      stages.splice(index, 1);\n    }\n    Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);\n    return this;\n  }\n  getPointerPosition() {\n    const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n    if (!pos) {\n      Util.warn(NO_POINTERS_MESSAGE);\n      return null;\n    }\n    return {\n      x: pos.x,\n      y: pos.y\n    };\n  }\n  _getPointerById(id) {\n    return this._pointerPositions.find(p => p.id === id);\n  }\n  getPointersPositions() {\n    return this._pointerPositions;\n  }\n  getStage() {\n    return this;\n  }\n  getContent() {\n    return this.content;\n  }\n  _toKonvaCanvas(config) {\n    config = config || {};\n    config.x = config.x || 0;\n    config.y = config.y || 0;\n    config.width = config.width || this.width();\n    config.height = config.height || this.height();\n    var canvas = new SceneCanvas({\n      width: config.width,\n      height: config.height,\n      pixelRatio: config.pixelRatio || 1\n    });\n    var _context = canvas.getContext()._context;\n    var layers = this.children;\n    if (config.x || config.y) {\n      _context.translate(-1 * config.x, -1 * config.y);\n    }\n    layers.forEach(function (layer) {\n      if (!layer.isVisible()) {\n        return;\n      }\n      var layerCanvas = layer._toKonvaCanvas(config);\n      _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n    });\n    return canvas;\n  }\n  getIntersection(pos) {\n    if (!pos) {\n      return null;\n    }\n    var layers = this.children,\n      len = layers.length,\n      end = len - 1,\n      n;\n    for (n = end; n >= 0; n--) {\n      const shape = layers[n].getIntersection(pos);\n      if (shape) {\n        return shape;\n      }\n    }\n    return null;\n  }\n  _resizeDOM() {\n    var width = this.width();\n    var height = this.height();\n    if (this.content) {\n      this.content.style.width = width + PX;\n      this.content.style.height = height + PX;\n    }\n    this.bufferCanvas.setSize(width, height);\n    this.bufferHitCanvas.setSize(width, height);\n    this.children.forEach(layer => {\n      layer.setSize({\n        width,\n        height\n      });\n      layer.draw();\n    });\n  }\n  add(layer) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n    if (arguments.length > 1) {\n      for (var i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n      return this;\n    }\n    super.add(layer);\n    var length = this.children.length;\n    if (length > MAX_LAYERS_NUMBER) {\n      Util.warn('The stage has ' + length + ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n    }\n    layer.setSize({\n      width: this.width(),\n      height: this.height()\n    });\n    layer.draw();\n    if (Konva.isBrowser) {\n      this.content.appendChild(layer.canvas._canvas);\n    }\n    return this;\n  }\n  getParent() {\n    return null;\n  }\n  getLayer() {\n    return null;\n  }\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n  getLayers() {\n    return this.children;\n  }\n  _bindContentEvents() {\n    if (!Konva.isBrowser) {\n      return;\n    }\n    EVENTS.forEach(_ref => {\n      let [event, methodName] = _ref;\n      this.content.addEventListener(event, evt => {\n        this[methodName](evt);\n      }, {\n        passive: false\n      });\n    });\n  }\n  _pointerenter(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n    this._fire(events.pointerenter, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n  _pointerover(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n    this._fire(events.pointerover, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n  _getTargetShape(evenType) {\n    let shape = this[evenType + 'targetShape'];\n    if (shape && !shape.getStage()) {\n      shape = null;\n    }\n    return shape;\n  }\n  _pointerleave(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    this.setPointersPositions(evt);\n    var targetShape = this._getTargetShape(eventType);\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n    if (targetShape && eventsEnabled) {\n      targetShape._fireAndBubble(events.pointerout, {\n        evt: evt\n      });\n      targetShape._fireAndBubble(events.pointerleave, {\n        evt: evt\n      });\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n      this[eventType + 'targetShape'] = null;\n    } else if (eventsEnabled) {\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n      this._fire(events.pointerout, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n    this.pointerPos = undefined;\n    this._pointerPositions = [];\n  }\n  _pointerdown(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    this.setPointersPositions(evt);\n    var triggeredOnShape = false;\n    this._changedPointerPositions.forEach(pos => {\n      var shape = this.getIntersection(pos);\n      DD.justDragged = false;\n      Konva['_' + eventType + 'ListenClick'] = true;\n      const hasShape = shape && shape.isListening();\n      if (!hasShape) {\n        return;\n      }\n      if (Konva.capturePointerEventsEnabled) {\n        shape.setPointerCapture(pos.id);\n      }\n      this[eventType + 'ClickStartShape'] = shape;\n      shape._fireAndBubble(events.pointerdown, {\n        evt: evt,\n        pointerId: pos.id\n      });\n      triggeredOnShape = true;\n      const isTouch = evt.type.indexOf('touch') >= 0;\n      if (shape.preventDefault() && evt.cancelable && isTouch) {\n        evt.preventDefault();\n      }\n    });\n    if (!triggeredOnShape) {\n      this._fire(events.pointerdown, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._pointerPositions[0].id\n      });\n    }\n  }\n  _pointermove(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n      evt.preventDefault();\n    }\n    this.setPointersPositions(evt);\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n    if (!eventsEnabled) {\n      return;\n    }\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n    var targetShape = this._getTargetShape(eventType);\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      var differentTarget = targetShape !== shape;\n      if (differentTarget && targetShape) {\n        targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);\n        targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);\n      }\n      if (shape) {\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n        processedShapesIds[shape._id] = true;\n      }\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n        if (differentTarget) {\n          shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);\n          shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);\n          this[eventType + 'targetShape'] = shape;\n        }\n        shape._fireAndBubble(events.pointermove, Object.assign({}, event));\n      } else {\n        if (targetShape) {\n          this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n          this[eventType + 'targetShape'] = null;\n        }\n      }\n    });\n    if (!triggeredOnShape) {\n      this._fire(events.pointermove, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n  }\n  _pointerup(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    this.setPointersPositions(evt);\n    const clickStartShape = this[eventType + 'ClickStartShape'];\n    const clickEndShape = this[eventType + 'ClickEndShape'];\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n      if (shape) {\n        shape.releaseCapture(pos.id);\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n        processedShapesIds[shape._id] = true;\n      }\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      let fireDblClick = false;\n      if (Konva['_' + eventType + 'InDblClickWindow']) {\n        fireDblClick = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      } else if (!DD.justDragged) {\n        Konva['_' + eventType + 'InDblClickWindow'] = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      }\n      this[eventType + 'DblTimeout'] = setTimeout(function () {\n        Konva['_' + eventType + 'InDblClickWindow'] = false;\n      }, Konva.dblClickWindow);\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n        this[eventType + 'ClickEndShape'] = shape;\n        shape._fireAndBubble(events.pointerup, Object.assign({}, event));\n        if (Konva['_' + eventType + 'ListenClick'] && clickStartShape && clickStartShape === shape) {\n          shape._fireAndBubble(events.pointerclick, Object.assign({}, event));\n          if (fireDblClick && clickEndShape && clickEndShape === shape) {\n            shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));\n          }\n        }\n      } else {\n        this[eventType + 'ClickEndShape'] = null;\n        if (Konva['_' + eventType + 'ListenClick']) {\n          this._fire(events.pointerclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n        if (fireDblClick) {\n          this._fire(events.pointerdblclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n      }\n    });\n    if (!triggeredOnShape) {\n      this._fire(events.pointerup, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n    Konva['_' + eventType + 'ListenClick'] = false;\n    if (evt.cancelable && eventType !== 'touch') {\n      evt.preventDefault();\n    }\n  }\n  _contextmenu(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(CONTEXTMENU, {\n        evt: evt\n      });\n    } else {\n      this._fire(CONTEXTMENU, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n  _wheel(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(WHEEL, {\n        evt: evt\n      });\n    } else {\n      this._fire(WHEEL, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n  _pointercancel(evt) {\n    this.setPointersPositions(evt);\n    const shape = PointerEvents.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());\n    if (shape) {\n      shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n    }\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n  _lostpointercapture(evt) {\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n  setPointersPositions(evt) {\n    var contentPosition = this._getContentPosition(),\n      x = null,\n      y = null;\n    evt = evt ? evt : window.event;\n    if (evt.touches !== undefined) {\n      this._pointerPositions = [];\n      this._changedPointerPositions = [];\n      Array.prototype.forEach.call(evt.touches, touch => {\n        this._pointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n      Array.prototype.forEach.call(evt.changedTouches || evt.touches, touch => {\n        this._changedPointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n    } else {\n      x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n      y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n      this.pointerPos = {\n        x: x,\n        y: y\n      };\n      this._pointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n      this._changedPointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n    }\n  }\n  _setPointerPosition(evt) {\n    Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n    this.setPointersPositions(evt);\n  }\n  _getContentPosition() {\n    if (!this.content || !this.content.getBoundingClientRect) {\n      return {\n        top: 0,\n        left: 0,\n        scaleX: 1,\n        scaleY: 1\n      };\n    }\n    var rect = this.content.getBoundingClientRect();\n    return {\n      top: rect.top,\n      left: rect.left,\n      scaleX: rect.width / this.content.clientWidth || 1,\n      scaleY: rect.height / this.content.clientHeight || 1\n    };\n  }\n  _buildDOM() {\n    this.bufferCanvas = new SceneCanvas({\n      width: this.width(),\n      height: this.height()\n    });\n    this.bufferHitCanvas = new HitCanvas({\n      pixelRatio: 1,\n      width: this.width(),\n      height: this.height()\n    });\n    if (!Konva.isBrowser) {\n      return;\n    }\n    var container = this.container();\n    if (!container) {\n      throw 'Stage has no container. A container is required.';\n    }\n    container.innerHTML = '';\n    this.content = document.createElement('div');\n    this.content.style.position = 'relative';\n    this.content.style.userSelect = 'none';\n    this.content.className = 'konvajs-content';\n    this.content.setAttribute('role', 'presentation');\n    container.appendChild(this.content);\n    this._resizeDOM();\n  }\n  cache() {\n    Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n    return this;\n  }\n  clearCache() {\n    return this;\n  }\n  batchDraw() {\n    this.getChildren().forEach(function (layer) {\n      layer.batchDraw();\n    });\n    return this;\n  }\n}\nStage.prototype.nodeType = STAGE;\n_registerNode(Stage);\nFactory.addGetterSetter(Stage, 'container');","map":null,"metadata":{},"sourceType":"module"}