{"ast":null,"code":"var _jsxFileName = \"/home/meparth/kn-projekt/Frontend/src/Components/Editor/Elements/Rectangle.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport { useEffect } from 'react';\nimport { Rect, Transformer } from 'react-konva';\nimport useImage from 'use-image';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Rectangle = _ref => {\n  _s();\n  let {\n    element,\n    setIsDragging,\n    editPositionOfElement,\n    selectedId,\n    setSelectedId,\n    editDimensionsOfElement,\n    addHelperLine,\n    stageDimensions\n  } = _ref;\n  const [isMouseOver, setIsMouseOver] = useState(false);\n  const [counter, setCounter] = useState(0);\n  const [image, status] = useImage(element.fillPatternImage, 'Anonymous');\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  React.useEffect(() => {\n    if (selectedId == element.id && element.isLocked == false) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [selectedId]);\n  React.useEffect(() => {\n    let temp = counter + 2;\n    setCounter(temp);\n  }, [element.fillPatternOffsetX, element.fillPatternOffsetY, element.fillPatternRotation, element.isLocked]);\n\n  /////////////////////////\n  ////////////////////////\n  return /*#__PURE__*/_jsxDEV(React.Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(Rect, {\n      ref: shapeRef,\n      draggable: element.isLocked ? false : true,\n      x: element.x,\n      y: element.y,\n      name: element.id,\n      stroke: element.strokeColor,\n      strokeWidth: element.strokeWidth,\n      width: element.width,\n      rotation: element.rotation,\n      height: element.height,\n      cornerRadius: element.cornerRadius,\n      fill: element.fill !== null ? element.fill : undefined,\n      fillPatternImage: image,\n      fillPatternOffset: {\n        x: element.fillPatternOffsetX,\n        y: element.fillPatternOffsetY\n      },\n      fillPatternRepeat: \"no-repeat\",\n      fillPatternScaleX: element.fillPatternScaleX,\n      fillPatternScaleY: element.fillPatternScaleY,\n      fillPatternRotation: element.fillPatternRotation,\n      opacity: element.opacity,\n      onMouseOver: event => {\n        setIsMouseOver(true);\n      },\n      onMouseLeave: event => {\n        setIsMouseOver(false);\n      },\n      onClick: event => {\n        setSelectedId(element.id);\n        if (!element.isLocked) {\n          // event.target.moveToTop();\n          // trRef.current !== null && trRef.current.moveToTop();\n        }\n      },\n      onTap: event => {\n        setSelectedId(element.id);\n        if (!element.isLocked) {\n          // event.target.moveToTop();\n          // trRef.current !== null && trRef.current.moveToTop();\n        }\n      },\n      onDragMove: event => {\n        // event.target.moveToTop()\n      },\n      onDragStart: event => {\n        setIsDragging(true);\n      },\n      onDragEnd: event => {\n        editPositionOfElement(element.id, event);\n        setIsDragging(false);\n      },\n      onTransformStart: e => {\n        setIsDragging(true);\n      },\n      onTransform: e => {\n        editPositionOfElement(element.id, e);\n      },\n      onTransformEnd: e => {\n        const node = shapeRef.current;\n        const scaleX = node.scaleX();\n        const scaleY = node.scaleY();\n\n        // we will reset it back\n        node.scaleX(1);\n        node.scaleY(1);\n        var width = Math.max(5, node.width() * scaleX);\n        var height = Math.max(node.height() * scaleY);\n        editDimensionsOfElement(element.id, width, height); // node is the transformer we need to get its dimension and set it to the image\n        setIsDragging(false);\n      }\n    }, counter, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 7\n    }, this), selectedId == element.id && /*#__PURE__*/_jsxDEV(Transformer, {\n      name: counter,\n      ref: trRef,\n      boundBoxFunc: (oldBox, newBox) => {\n        // limit resize\n        if (newBox.width < 5 || newBox.height < 5) {\n          return oldBox;\n        }\n        return newBox;\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 34,\n    columnNumber: 5\n  }, this);\n};\n_s(Rectangle, \"0ubF5RvjYQ9TQEF54JR0UdkF8JM=\", false, function () {\n  return [useImage];\n});\n_c = Rectangle;\nvar _c;\n$RefreshReg$(_c, \"Rectangle\");","map":{"version":3,"names":["React","useState","useEffect","Rect","Transformer","useImage","jsxDEV","_jsxDEV","Rectangle","_ref","_s","element","setIsDragging","editPositionOfElement","selectedId","setSelectedId","editDimensionsOfElement","addHelperLine","stageDimensions","isMouseOver","setIsMouseOver","counter","setCounter","image","status","fillPatternImage","shapeRef","useRef","trRef","id","isLocked","current","nodes","getLayer","batchDraw","temp","fillPatternOffsetX","fillPatternOffsetY","fillPatternRotation","Fragment","children","ref","draggable","x","y","name","stroke","strokeColor","strokeWidth","width","rotation","height","cornerRadius","fill","undefined","fillPatternOffset","fillPatternRepeat","fillPatternScaleX","fillPatternScaleY","opacity","onMouseOver","event","onMouseLeave","onClick","onTap","onDragMove","onDragStart","onDragEnd","onTransformStart","e","onTransform","onTransformEnd","node","scaleX","scaleY","Math","max","fileName","_jsxFileName","lineNumber","columnNumber","boundBoxFunc","oldBox","newBox","_c","$RefreshReg$"],"sources":["/home/meparth/kn-projekt/Frontend/src/Components/Editor/Elements/Rectangle.js"],"sourcesContent":["import React, { useState } from 'react'\r\nimport { useEffect } from 'react';\r\nimport { Rect, Transformer } from 'react-konva';\r\nimport useImage from 'use-image';\r\n\r\nexport const Rectangle = ({\r\n  element, setIsDragging, editPositionOfElement, selectedId, setSelectedId, editDimensionsOfElement, addHelperLine, stageDimensions\r\n}) => {\r\n  const [isMouseOver, setIsMouseOver] = useState(false)\r\n  const [counter, setCounter] = useState(0)\r\n\r\n  const [image, status] = useImage(element.fillPatternImage, 'Anonymous');\r\n\r\n  const shapeRef = React.useRef();\r\n  const trRef = React.useRef();\r\n\r\n  React.useEffect(() => {\r\n    if (selectedId == element.id && element.isLocked == false) {\r\n      // we need to attach transformer manually\r\n      trRef.current.nodes([shapeRef.current]);\r\n      trRef.current.getLayer().batchDraw();\r\n    }\r\n  }, [selectedId,]);\r\n\r\n  React.useEffect(() => {\r\n    let temp = counter + 2;\r\n    setCounter(temp)\r\n\r\n  }, [element.fillPatternOffsetX, element.fillPatternOffsetY,element.fillPatternRotation, element.isLocked]);\r\n\r\n  /////////////////////////\r\n  ////////////////////////\r\n  return (\r\n    <React.Fragment>\r\n      <Rect\r\n        key={counter}\r\n        ref={shapeRef}\r\n        draggable={element.isLocked ? false : true}\r\n        x={element.x}\r\n        y={element.y}\r\n        name={element.id}\r\n        stroke={element.strokeColor}\r\n        strokeWidth={element.strokeWidth}\r\n        width={element.width}\r\n        rotation={element.rotation}\r\n        height={element.height}\r\n        cornerRadius={element.cornerRadius}\r\n        fill={element.fill !== null ? element.fill : undefined}\r\n        fillPatternImage={image}\r\n        fillPatternOffset={{ x: element.fillPatternOffsetX, y: element.fillPatternOffsetY }}\r\n        fillPatternRepeat=\"no-repeat\"\r\n        fillPatternScaleX={element.fillPatternScaleX}\r\n        fillPatternScaleY={element.fillPatternScaleY}\r\n        fillPatternRotation={element.fillPatternRotation}\r\n        opacity={element.opacity}\r\n\r\n\r\n        onMouseOver={(event) => {\r\n          setIsMouseOver(true)\r\n        }}\r\n\r\n        onMouseLeave={(event) => {\r\n          setIsMouseOver(false)\r\n        }}\r\n\r\n        onClick={(event) => {\r\n          setSelectedId(element.id);\r\n\r\n          if (!element.isLocked) {\r\n            // event.target.moveToTop();\r\n            // trRef.current !== null && trRef.current.moveToTop();\r\n          }\r\n\r\n        }\r\n        }\r\n        onTap={(event) => {\r\n          setSelectedId(element.id);\r\n\r\n          if (!element.isLocked) {\r\n            // event.target.moveToTop();\r\n            // trRef.current !== null && trRef.current.moveToTop();\r\n          }\r\n\r\n        }\r\n        }\r\n        onDragMove={(event) => {\r\n          // event.target.moveToTop()\r\n        }\r\n        }\r\n        onDragStart={(event) => {\r\n          setIsDragging(true)\r\n        }}\r\n        onDragEnd={(event) => {\r\n          editPositionOfElement(element.id, event)\r\n          setIsDragging(false)\r\n\r\n        }}\r\n        onTransformStart={(e) => {\r\n          setIsDragging(true);\r\n        }}\r\n        onTransform={\r\n          (e) => {\r\n\r\n            editPositionOfElement(element.id, e)\r\n\r\n          }\r\n        }\r\n        onTransformEnd={(e) => {\r\n          const node = shapeRef.current;\r\n          const scaleX = node.scaleX();\r\n          const scaleY = node.scaleY();\r\n\r\n          // we will reset it back\r\n          node.scaleX(1);\r\n          node.scaleY(1);\r\n\r\n          var width = Math.max(5, node.width() * scaleX);\r\n          var height = Math.max(node.height() * scaleY);\r\n          editDimensionsOfElement(element.id, width, height) // node is the transformer we need to get its dimension and set it to the image\r\n          setIsDragging(false)\r\n\r\n        }}\r\n      />\r\n\r\n\r\n      {selectedId == element.id && (\r\n        <Transformer\r\n          name={counter}\r\n          ref={trRef}\r\n          boundBoxFunc={(oldBox, newBox) => {\r\n            // limit resize\r\n            if (newBox.width < 5 || newBox.height < 5) {\r\n              return oldBox;\r\n            }\r\n            return newBox;\r\n          }\r\n          }\r\n        />\r\n      )}\r\n\r\n\r\n    </React.Fragment>\r\n  )\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}